package ms.ipp;

import static java.lang.System.arraycopy;
import static java.util.Arrays.asList;
import static ms.ipp.Algorithms.reduce;
import static ms.ipp.Algorithms.toKV;
import static ms.ipp.Streams.stream;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.NavigableMap;
import java.util.Set;
import java.util.Spliterator;
import java.util.Spliterators;
import java.util.TreeMap;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.BiPredicate;
import java.util.function.BinaryOperator;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.function.Supplier;
import java.util.regex.Pattern;
import java.util.stream.Collector;
import java.util.stream.Collectors;
import java.util.stream.DoubleStream;
import java.util.stream.IntStream;
import java.util.stream.Stream;

import ms.ipp.base.KeyValue;
import ms.ipp.iterable.BiIterable;
import ms.ipp.iterable.FilteredIterable;
import ms.ipp.iterable.MappedIterable;
import ms.ipp.iterable.ProxyBiIterable;
import ms.ipp.iterator.FilteredIterator;

/**
 * @author saienko
 * 
 */
public class Iterables {
    /**
     * A No-Op
     */
    public static Runnable NULL_CALL = () -> {
    };

    ///////////////////////////////////////////////////////
    /// *********** BiIterable Manipulation *********** ///
    ///////////////////////////////////////////////////////

    /**
     * Returns a {@code BiIterable} which maps all elements from the original {@code BiIterable} by
     * means of a given mapping function.
     * 
     * @param it
     * @param map
     * @return
     */
    public static <T, U, V, W> BiIterable<V, W> mapped(BiIterable<T, U> it,
                                                       BiFunction<? super T, ? super U, Entry<V, W>> map) {
        return toBiIt(mapped(removeProxies(it), toKV(map)));
    }

    /**
     * Returns a {@code BiIterable} which contains only those elements from the original
     * {@code BiIterable} which satisfy a given {@code BiPredicate}.
     * 
     * @param it
     * @param pred
     * @return
     */
    public static <T, U> BiIterable<T, U> filtered(BiIterable<T, U> it,
                                                   BiPredicate<? super T, ? super U> pred) {
        return pred == null ? it : toBiIt(filtered(removeProxies(it), toKV(pred)));
    }

    /**
     * Returns a {@code BiIterable} which contains elements with distinct keys. The key for each
     * element is generated by a given {@code BiFunction}.
     * 
     * @param it
     * @param keyExtractor the {@code BiFunction} which generates keys for elements
     * @return
     */
    public static <T, U> BiIterable<T, U> distinct(BiIterable<T, U> it,
                                                   BiFunction<? super T, ? super U, ?> keyExtractor) {
        return toBiIt(distinct(removeProxies(it), toKV(keyExtractor)));
    }

    /**
     * Returns a {@code BiIterable} which calls a given {@code BiConsumer} prior to deleting an
     * element. The element is passed to hook as the first and the only argument.
     * 
     * @param it
     * @param onDelete
     * @return
     */
    public static <T, U> BiIterable<T, U> deleteHook(BiIterable<T, U> it,
                                                     BiConsumer<? super T, ? super U> onDelete) {
        return toBiIt(deleteHook(removeProxies(it), toKV(onDelete)));
    }

    /**
     * Returns true if all elements in the {@code BiIterable} satisfy a given {@code BiPredicate}.
     * 
     * @param it   the original BiIterable, not null
     * @param pred the predicate. If null, true is returned.
     * @return
     */
    public static <T, U> boolean all(BiIterable<T, U> it, BiPredicate<? super T, ? super U> pred) {
        return all(it, toKV(pred));
    }

    /**
     * Returns true if none of the elements in the {@code BiIterable} satisfy a given
     * {@code BiPredicate}.
     * 
     * @param it   the original BiIterable, not null
     * @param pred the predicate. If null, returns true is the BiIterable is empty
     * @return
     */
    public static <T, U> boolean none(BiIterable<T, U> it, BiPredicate<? super T, ? super U> pred) {
        return none(it, toKV(pred));
    }

    /**
     * Returns true if at least one of the elements in the {@code BiIterable} satisfies a given
     * {@code BiPredicate}.
     * 
     * @param it   the original BiIterable, not null
     * @param pred the predicate. If null, returns true if the BiIterable is not empty
     * @return
     */
    public static <T, U> boolean any(BiIterable<T, U> it, BiPredicate<? super T, ? super U> pred) {
        return any(it, toKV(pred));
    }

    /**
     * If there is exactly one item in the {@code BiIterable} which satisfies a given
     * {@code BiPredicate}, returns the element. If there are no items satisfying the
     * {@code Predicate}, returns null. If there are more than one items, throws
     * {@link IllegalArgumentException}.
     * 
     * @param it   the original BiIterable, not null
     * @param pred the predicate, null is interpreted as a condition which always returns true.
     * @return
     */
    public static <T, U> Entry<T, U> unique(BiIterable<T, U> it,
                                            BiPredicate<? super T, ? super U> pred) {
        return unique(it, toKV(pred));
    }

    /**
     * Returns the first element encountered in the {@code BiIterable} which satisfies a given
     * {@code BiPredicate}.
     * 
     * @param it   the original BiIterable, not null
     * @param pred the predicate, null is interpreted as a condition which always returns true
     * @return
     */
    public static <T, U> Entry<T, U> first(BiIterable<T, U> it,
                                           BiPredicate<? super T, ? super U> pred) {
        return first(it, toKV(pred));
    }

    /**
     * Performs a given action on all elements from the {@code BiIterable}.
     * 
     * @param it   the original BiIterable, not null
     * @param proc the action to perform on eligible elements, not null
     * @return
     */
    public static <T, U> void forEach(BiIterable<T, U> it, BiConsumer<? super T, ? super U> proc) {
        forEach(it, toKV(proc));
    }

    /**
     * Removes all elements from the {@code BiIterable} which satisfy a given {@code BiPredicate}.
     * 
     * @param it   the original BiIterable, not null
     * @param pred the predicate. If null, all elements will be removed
     * @return true if at least one element has been removed
     */
    public static <T, U> boolean removeFrom(BiIterable<T, U> it,
                                            BiPredicate<? super T, ? super U> pred) {
        return removeFrom(it, toKV(pred));
    }

    /**
     * Collects all elements from the {@code BiIterable} which satisfy a given {@code BiPredicate}
     * to a {@code List}.
     * 
     * @param st   the original BiIterable, not null
     * @param pred the predicate. If null, the original BiIterable is used
     * @return
     */
    public static <T, U> List<Entry<T, U>> list(BiIterable<T, U> it,
                                                BiPredicate<? super T, ? super U> pred) {
        return list(it, toKV(pred));
    }

    /**
     * Converts a given {@code Iterable<Entry<T,U>>} to a {@code BiIterable<T,U>}.
     * 
     * @param it the original Iterable. Null returns null. If the source is already BiIterable, it
     *           is returned unchanged.
     * @return
     */
    @SuppressWarnings("unchecked")
    public static <T, U> BiIterable<T, U> toBiIt(Iterable<? extends Entry<T, U>> it) {
        if (it == null) {
            return null;
        } else if (it instanceof BiIterable) {
            return (BiIterable<T, U>) it;
        } else {
            return new ProxyBiIterable<>((Iterable<Entry<T, U>>) it);
        }
    }

    @SuppressWarnings("unchecked")
    private static <T, U> Iterable<Entry<T, U>> removeProxies(Iterable<Entry<T, U>> source) {
        while (source instanceof ProxyBiIterable) {
            source = ((ProxyBiIterable<T, U>) source).getSource();
        }
        return source;
    }
    ///////////////////////////////////////////////////////
    /// ************ Iterable Manipulation ************ ///
    ///////////////////////////////////////////////////////

    /**
     * Returns an {@code Iterable} which maps all elements from the original {@code Iterable} by
     * means of a given mapping function.
     * 
     * @param it
     * @param map
     * @return
     */
    public static <T, U> Iterable<U> mapped(Iterable<T> it, Function<? super T, U> map) {
        return new MappedIterable<>(it, map);
    }

    private static <T> Iterable<T> filtered(Iterable<T> it, Supplier<Predicate<? super T>> filter) {
        return filter == null ? it : new FilteredIterable<>(it).setFilter(filter);
    }

    /**
     * Returns an {@code Iterable} which contains only those elements from the original
     * {@code Iterable} which satisfy a given {@code Predicate}.
     * 
     * @param it
     * @param pred
     * @return
     */
    public static <T> Iterable<T> filtered(Iterable<T> it, Predicate<? super T> pred) {
        return pred == null ? it : filtered(it, () -> pred);
    }

    /**
     * Returns an {@code Iterable} which contains elements with distinct keys. The key for each
     * element is generated by a given {@code Function}.
     * 
     * @param it
     * @param keyExtractor the {@code Function} which generates keys for elements
     * @return
     */
    public static <T> Iterable<T> distinct(Iterable<T> it, Function<? super T, ?> keyExtractor) {
        // we only return a predicate-supplier. Otherwise, the "seen" set in the
        // distinctByKey-method would be instantiated now and not upon calling
        // the iterator()-method
        return filtered(it, () -> FilteredIterator.distinctByKey(keyExtractor));
    }

    /**
     * Returns an {@code Iterable} which calls a given {@code Consumer} prior to deleting an
     * element. The element is passed to hook as the first and the only argument.
     * 
     * @param it
     * @param onDelete
     * @return
     */
    public static <T> Iterable<T> deleteHook(Iterable<T> source, Consumer<? super T> onDelete) {
        return onDelete == null ? source : new FilteredIterable<>(source).setOnDelete(onDelete);
    }

    /**
     * Returns true if all elements in the {@code Iterable} satisfy a given {@code Predicate}.
     * 
     * @param it   the original Iterable, not null
     * @param pred the predicate. If null, true is returned.
     * @return
     */
    public static <T> boolean all(Iterable<T> it, Predicate<? super T> pred) {
        return Streams.all(stream(it), pred);
    }

    /**
     * Returns true if none of the elements in the {@code Iterable} satisfy a given
     * {@code Predicate}.
     * 
     * @param it   the original Iterable, not null
     * @param pred the predicate. If null, returns true is the Iterable is empty
     * @return
     */
    public static <T> boolean none(Iterable<T> it, Predicate<? super T> pred) {
        return Streams.none(stream(it), pred);
    }

    /**
     * Returns true if at least one of the elements in the {@code Iterable} satisfies a given
     * {@code Predicate}
     * 
     * @param it   the original Iterable, not null
     * @param pred the predicate. If null, returns true if the Iterable is not empty.
     * @return
     */
    public static <T> boolean any(Iterable<T> it, Predicate<? super T> pred) {
        return Streams.any(stream(it), pred);
    }

    /**
     * If there is exactly one item in the {@code Iterable} which satisfies a given
     * {@code Predicate}, returns the element. If there are no items satisfying the
     * {@code Predicate}, returns null. If there are more than one items, throws
     * {@link IllegalArgumentException}.
     * 
     * @param it
     * @param pred
     * @return
     */
    public static <T> T unique(Iterable<T> it, Predicate<? super T> pred) {
        return Streams.unique(stream(it), pred);
    }

    /**
     * @return the first element encountered in the {@code Iterable} which satisfies a given
     *         {@code Predicate} and null otherwise.
     * 
     * @param it   the original Iterable, not null
     * @param pred the predicate, null is interpreted as a condition which always returns true
     * 
     */
    public static <T> T first(Iterable<T> it, Predicate<? super T> pred) {
        return Streams.first(stream(it), pred);
    }

    /**
     * Performs a given action on all elements from the {@code Iterable}.
     * 
     * @param it   the original Iterable, not null
     * @param proc the action to perform on eligible elements, not null
     * @return
     */
    public static <T> void forEach(Iterable<T> it, Consumer<? super T> proc) {
        // we don't have to create streams for this
        if (it != null) {
            it.forEach(proc);
        }
    }

    /**
     * Removes all elements from the {@code Iterable} which satisfy a given {@code Predicate}.
     * 
     * @param it   the original Iterable, not null
     * @param pred the predicate. If null, all elements will be removed
     * @return true if at least one element has been removed
     */
    public static <T> boolean removeFrom(Iterable<T> it, Predicate<? super T> pred) {
        boolean removed = false;
        Iterator<T> itr = it.iterator();
        if (pred == null) {
            pred = t -> true;
        }
        while (itr.hasNext()) {
            if (pred.test(itr.next())) {
                itr.remove();
                removed = true;
            }
        }
        return removed;
    }

    /**
     * Returns the number of elements in a given {@code Iterable}
     * 
     * @param it
     * @return
     */
    public static <T> int count(Iterable<T> it) {
        return list(it).size();
    }

    /**
     * Collects all elements from the {@code Iterable} to a {@code List}.
     * 
     * @param it the original BiIterable, not null
     * @return
     */
    public static <T, U extends T> List<T> list(Iterable<U> it) {
        return list(it, null);
    }

    /**
     * Collects all elements from the {@codeIterable} which satisfy a given {@code BiPredicate} to a
     * {@code List}.
     * 
     * @param it   the original Iterable, not null
     * @param pred the predicate. If null, the original Iterable is used
     * @return
     */
    @SuppressWarnings("unchecked")
    public static <T, U extends T> List<T> list(Iterable<U> it, Predicate<? super U> pred) {
        if (pred == null && it instanceof List) {
            return (List<T>) it;
        }
        return Streams.list(stream(it), pred);
    }

    /**
     * Collects all elements from the {@code Iterable} which satisfy a given {@code BiPredicate} to
     * a {@code Set}.
     * 
     * @param it   the original Iterable, not null
     * @param pred the predicate. If null, the original Iterable is used
     * @return
     */
    @SuppressWarnings("unchecked")
    public static <T, U extends T> Set<T> set(Iterable<U> it, Predicate<? super U> pred) {
        if (pred == null && it instanceof Set) {
            return (Set<T>) it;
        }
        return Streams.set(stream(it), pred);
    }

    public static <T, U> Map<T, U> toHashMap(Iterable<? extends Entry<T, U>> it) {
        return toHashMap(it, Entry::getKey, Entry::getValue);
    }

    public static <T, U> Map<T, U> toHashMap(Iterable<? extends U> it,
                                             Function<? super U, T> keyGen) {
        return toHashMap(it, keyGen, Function.identity());
    }

    public static <T, U, V> Map<T, V> toHashMap(Iterable<? extends U> it,
                                                Function<? super U, T> keyGen,
                                                Function<? super U, V> valueGen) {
        return collect(it, null, Collectors.toMap(keyGen, valueGen));
    }

    /**
     * Collects all elements from the {@code Iterable<Entry<T,U>>} a {@code Map<T,U>}.
     * 
     * @param it
     * @return
     */
    public static <T, U> Map<T, U> toTreeMap(Iterable<? extends Entry<T, U>> it) {
        return toTreeMap(it, Entry::getKey, Entry::getValue);
    }

    public static <T, U> TreeMap<T, U> toTreeMap(Iterable<? extends U> it,
                                                 Function<? super U, T> keyGen) {
        return toTreeMap(it, keyGen, e -> e);
    }

    public static <T, U, V> TreeMap<T, V> toTreeMap(Iterable<? extends U> it,
                                                    Function<? super U, T> keyGen,
                                                    Function<? super U, V> valueGen) {
        return collect(it, null, toTreeMap(keyGen, valueGen));
    }

    private static <T> BinaryOperator<T> throwingMerger() {
        return (u, v) -> {
            throw new IllegalStateException(String.format("Duplicate key %s", u));
        };
    }

    public static <T, K, U> Collector<T, ?, TreeMap<K, U>> toTreeMap(Function<? super T, ? extends K> keyMapper,
                                                                     Function<? super T, ? extends U> valueMapper) {
        // Adapted from Collectors.toMap(keyMapper, valueMapper)
        return Collectors.toMap(keyMapper, valueMapper, throwingMerger(), TreeMap::new);
    }

    /**
     * Collects all elements from the {@code Iterable} which satisfy a given {@code Predicate} by
     * using a given {@link Collector}.
     * 
     * @param st        the original Iterable, not null
     * @param pred      the predicate. If null, the original Iterable is used
     * @param collector the Collector, as it is used by @{code Stream::collect} methods
     */
    public static <T, R> R collect(Iterable<T> it,
                                   Predicate<? super T> pred,
                                   Collector<T, ?, R> collector) {
        return Streams.collect(stream(it), pred, collector);
    }

    /**
     * Collects at most the first {@code n} elements from the {@code Iterable} which satisfy a given
     * {@code Predicate} by using a given {@link Collector}.
     * 
     * @param st        the original Iterable, not null
     * @param pred      the predicate. If null, the original Iterable is used
     * @param collector the Collector, as it is used by @{code Stream::collect} methods.
     * @param n         the number of elements to collect
     */
    public static <T, R> R collect(Iterable<T> it,
                                   Predicate<? super T> pred,
                                   Collector<T, ?, R> collector,
                                   int n) {
        return Streams.collect(stream(it), pred, collector, n);
    }

    /**
     * Creates and returns an {@link Iterable} from a given supplier of iterators.
     * 
     * @param it
     * @return
     */
    public static <T> Iterable<T> toIterable(Supplier<Iterator<T>> it) {
        return toIterable(it, 0);
    }

    /**
     * Creates and returns an {@link Iterable} with given characteristics from a given supplier of
     * iterators.
     * 
     * @param it
     * @return
     */
    public static <T> Iterable<T> toIterable(Supplier<Iterator<T>> it, int chars) {
        Iterable<T> itr = new Iterable<T>() {
            @Override
            public Iterator<T> iterator() {
                return it.get();
            }

            @Override
            public Spliterator<T> spliterator() {
                return Spliterators.spliteratorUnknownSize(iterator(), chars);
            }
        };
        return itr;
    }

    ///// ************** Shortcuts for Collections ***************** /////
    /**
     * Returns a {@code List} containing all elements from the original {@code Collection}
     * transformed by means of a given mapping {@code Function}.
     * 
     * @param items
     * @param map
     * @return
     */
    public static <T, U> List<U> map(Iterable<T> items, Function<T, U> map) {
        return mapFilter(items, map, null);
    }

    /**
     * Returns a {@code List} containing all elements inserted by a given {@code parser} after
     * applying it to every element in a given {@code Collection}. Any exceptions thrown by the
     * {@code parser} are converted to {@link IllegalArgumentException}.
     * 
     * @param items  the original collection, not null
     * @param parser the BiConsumer which decides how to populate the resulting list, not null
     * @return
     * @throws IllegalArgumentException if items is null or parser throws.
     */
    public static <S, T> List<T> parseList(Collection<S> items, BiConsumer<S, List<T>> parser) {
        if (items == null) {
            throw new IllegalArgumentException("Can not convert a null list");
        }
        List<T> result = new ArrayList<>();
        for (S s : items) {
            try {
                parser.accept(s, result);
            } catch (Exception e) {
                throw new IllegalArgumentException("Parameter list " + items + " cannot be parsed");
            }
        }
        return result;
    }

    /**
     * Filters out all elements from the original {@code Collection} that do not satisfy a given
     * {@code Predicate} and returns a {@code List} containing all elements from the filtered
     * {@code Collection} transformed by means of a given mapping {@code Function}.
     * 
     * @param items
     * @param map
     * @return
     */
    public static <T, U> List<U> filterMap(Iterable<T> items,
                                           Predicate<T> pred,
                                           Function<T, U> mapper) {
        return Streams.list(Streams.mapped(Streams.filtered(stream(items), pred), mapper), null);
    }

    /**
     * Returns a {@code List} containing only elements from the original {@code Collection} which
     * are transformed by means of a given mapping {@code Function} and additionally satisfy a given
     * {@code Predicate} for the transformed values.
     * 
     * @param items
     * @param map
     * @param pred
     * @return
     */
    public static <T, U> List<U> mapFilter(Iterable<T> items,
                                           Function<T, U> map,
                                           Predicate<U> pred) {
        return Streams.list(Streams.mapped(stream(items), map), pred);
    }

    /**
     * Returns the number of elements in a given {@code Collection}.
     * 
     * @param items
     * @return
     */
    public static <T> int count(Collection<T> items) {
        return items.size();
    }

    ///// ************ Shortcuts for Collection serializing ************** /////
    /**
     * Serialises an array by interlacing all elements with ','.
     * 
     * @param array the source array, not null
     * @return
     */
    public static <T> String toString(T[] array) {
        StringBuffer buf = new StringBuffer(500);
        appendList(buf, Arrays.asList(array));
        return buf.toString();
    }

    /**
     * Is equivalent to:
     * 
     * <pre>
     * appendList(buf, items, "[", "]", ", ", (t, b) -> b.append(t.toString()));
     * </pre>
     * 
     * @param buf   the StringBuffer to add the serialised Collection to, not null
     * @param items the original Collection, not null
     * 
     */
    public static void appendList(StringBuffer buf, Collection<?> items) {
        appendList(buf, items, (t, b) -> b.append(t.toString()));
    }

    /**
     * Is equivalent to:
     * 
     * <pre>
     * appendList(buf, items, "[", "]", ", ", serializer);
     * </pre>
     * 
     * @param buf        the StringBuffer to add the serialised Collection to, not null
     * @param items      the original Collection, not null
     * @param serializer a BiConsumer which should add to a StringBuffer the serialised version on
     *                   the element passed, not null
     */
    public static <T> void appendList(StringBuffer buf,
                                      Collection<? extends T> items,
                                      BiConsumer<T, StringBuffer> serializer) {
        appendList(buf, items, "[", "]", ", ", serializer);
    }

    /**
     * Serialises a {@code Collection} by using a given opening string, a given closing string, a
     * given separator as well as a given serialiser for each element in the {@code Collection} and
     * adds the serialised content to a given {@code StringBuffer}.
     * 
     * @param buf        the StringBuffer to add the serialised Collection to, not null
     * @param items      the original Collection, not null
     * @param op         the string which is prepended to the serialised Collection, not null
     * @param cl         the string added to the serialised Collection at the end, not null
     * @param sep        the string to mark the two elements as separate, not null
     * @param serializer a BiConsumer which should add to a StringBuffer the serialised version on
     *                   the element passed, not null
     */
    public static <T> void appendList(StringBuffer buf,
                                      Iterable<? extends T> items,
                                      String op,
                                      String cl,
                                      String sep,
                                      BiConsumer<T, StringBuffer> serializer) {
        buf.append(op);

        int added = 0;
        for (T t : items) {
            serializer.accept(t, buf);
            buf.append(sep);
            added++;
        }

        if (added >= 1) {
            buf.delete(buf.length() - sep.length(), buf.length());
        }
        buf.append(cl);
    }

    /**
     * Serialises a {@code Collection} by using a given opening string, a given closing string, a
     * given separator as well as a given serialiser for each element in the {@code Collection} and
     * returns the serialised content. Internally, it creates an interim {@link StringBuffer}, calls
     * {@link #appendList(StringBuffer, Collection, String, String, String, BiConsumer)} and returns
     * the buffer's content.
     * 
     * @param items      the original Collection, not null
     * @param op         the string which is prepended to the serialised Collection, not null
     * @param cl         the string added to the serialised Collection at the end, not null
     * @param sep        the string to mark the two elements as separate, not null
     * @param serializer a BiConsumer which should add to a StringBuffer the serialised version on
     *                   the element passed, not null
     * @return
     */
    public static <T> String appendList(Iterable<? extends T> items,
                                        String op,
                                        String cl,
                                        String sep,
                                        BiConsumer<T, StringBuffer> serializer) {
        var sb = new StringBuffer(2000);
        appendList(sb, items, op, cl, sep, serializer);
        return sb.toString();
    }

    /**
     * Serialises a {@code Collection} by using a given opening string, a given closing string, a
     * given separator as well as a given serialiser for each element in the {@code Collection} and
     * returns the serialised content. Is equivalent to:
     * {@code appendList(items, op, cl, sep, (s, sb) -> sb.append(serializer.apply(s)));}
     * 
     * @param items      the original Collection, not null
     * @param op         the string which is prepended to the serialised Collection, not null
     * @param cl         the string added to the serialised Collection at the end, not null
     * @param sep        the string to mark the two elements as separate, not null
     * @param serializer a Function which generates a serialised version of a collection element
     *                   passed, not null
     * @return
     */
    public static <T> String appendList(Iterable<? extends T> items,
                                        String op,
                                        String cl,
                                        String sep,
                                        Function<T, String> serializer) {
        return appendList(items, op, cl, sep, (s, sb) -> sb.append(serializer.apply(s)));
    }

    ///// ************ Shortcuts for Lists ************** /////
    /**
     * Returns the first index on a given list, for which a given Predicate returns true. If no
     * elements satisfy the Predicate, returns -1.
     * 
     * @param list the original List. Null returns -1.
     * @param pred the Predicate to test, not null
     * @return
     */
    public static <T> int indexOf(List<T> list, Predicate<T> pred) {
        if (list == null) {
            return -1;
        }
        for (int i = 0; i < list.size(); ++i) {
            if (pred.test(list.get(i))) {
                return i;
            }
        }
        return -1;
    }

    /**
     * Returns the first index starting from the back of a given list, for which a given Predicate
     * returns true. If no elements satisfy the Predicate, returns -1.
     * 
     * @param list the original List. Null returns -1.
     * @param pred the Predicate to test, not null
     * @return
     */
    public static <T> int lastIndexOf(List<T> list, Predicate<T> pred) {
        if (list == null) {
            return -1;
        }
        for (int i = list.size() - 1; i >= 0; --i) {
            if (pred.test(list.get(i))) {
                return i;
            }
        }
        return -1;
    }

    /**
     * Returns an array which contains the indexes of the elements of {@code subList} in
     * {@code totalList}. The order of indexes in the resulting array correspond to the order of
     * elements in {@code subList}. If any element from {@code subList} is not found in the
     * {@code totalList}, its index in the resulting array is to -1.
     * 
     * @param totalList the list of all elements. If null, an empty list is used instead
     * @param subList   the list of elements whose indexes in the {@code totalList} need to be
     *                  found, not null
     * @return
     */
    public static <U> int[] getIndexes(List<U> totalList, List<U> subList) {
        totalList = totalList == null ? new ArrayList<>() : totalList;
        return totalList.stream().mapToInt(s -> subList.indexOf(s)).toArray();
    }

    public static <U> List<U> subByIndex(List<U> totalList, int[] indexes) {
        List<U> sublist = new ArrayList<>();
        for (int i = 0; i < indexes.length; ++i) {
            sublist.add(totalList.get(indexes[i]));
        }
        return sublist;
    }

    ///// ************ Shortcuts for Maps ************** /////
    /**
     * Performs a given action on an element with a given key if such element exists. Is equivalent
     * to:
     * 
     * <pre>
     * ifExistsDo(name, attrs, null, proc);
     * </pre>
     * 
     * @param name  the key of the target element, not null
     * @param attrs a string-based map with elements, not null
     * @param proc  the action to be performed on the element with a given key, not null.
     */
    public static <T> void ifExistsDo(String name,
                                      Map<String, ? extends Object> attrs,
                                      Consumer<T> proc) {
        ifExistsDo(name, attrs, null, proc);
    }

    /**
     * Performs a given action on an element with a given key if such element exists and is not
     * contained in a given list of elements to be ignored.
     * 
     * @param name   the key of the target element, not null
     * @param attrs  a string-based map with elements, not null
     * @param ignore a list with keys to be ignored, may be null.
     * @param proc   the action to be performed on the element with a given key, not null.
     */
    @SuppressWarnings("unchecked")
    public static <T> void ifExistsDo(String name,
                                      Map<String, ? extends Object> attrs,
                                      List<String> ignore,
                                      Consumer<T> proc) {
        if (attrs.containsKey(name) && (ignore == null || !ignore.contains(name))) {
            proc.accept((T) attrs.get(name));
        }
    }

    public static <T, U> U ifExistsApply(String name,
                                         Map<String, ? extends Object> attrs,
                                         Function<T, U> func,
                                         Supplier<U> onMiss) {
        return ifExistsApply(name, attrs, null, func, onMiss);
    }

    @SuppressWarnings("unchecked")
    public static <T, U> U ifExistsApply(String name,
                                         Map<String, ? extends Object> attrs,
                                         List<String> ignore,
                                         Function<T, U> func,
                                         Supplier<U> onMiss) {
        if (attrs.containsKey(name) && (ignore == null || !ignore.contains(name))) {
            return func.apply((T) attrs.get(name));
        } else {
            return onMiss == null ? null : onMiss.get();
        }
    }

    /**
     * Groups an {@link Iterable} into a {@link Map} of Lists of elements grouped by a key provided
     * by a given generator.<br>
     * 
     * <b>NOTE:</b> Values, for which the keyGen returns null, will not be saved in the resulting
     * Map!
     * 
     * @param <K>    the class of the key in the resulting Map.
     * @param <V>    the class of the input values in the Iterable as well as in the resulting Map.
     * 
     * @param source the elements to be grouped.
     * @param keyGen
     * @return
     */
    public static <K, V, M extends Map<K, List<V>>> M group(Iterable<V> source,
                                                            Function<V, K> keyGen,
                                                            Supplier<M> generator) {
        M result = generator.get();
        for (V value : source) {
            K key = keyGen.apply(value);
            if (key != null) {
                Iterables.getInsert(key, result).add(value);
            }
        }
        return result;
    }

    /**
     * Returns the list with a given key from a given map of lists. If the list doesn't exist or is
     * null, a new empty {@link ArrayList} is inserted into the map prior to being returned.
     * 
     * @param key
     * @param map
     * @return
     */
    public static <T, U> List<U> getInsert(T key, Map<T, List<U>> map) {
        return getInsert(key, map, ArrayList::new);
    }

    /**
     * Returns the element with a given key from a given map. If the element doesn't exist or is
     * null, it is created by means of a given Supplier and inserted into the map prior to being
     * returned.
     * 
     * @param key
     * @param map
     * @param onNull is called when the element is null or doesn't exist, not null.
     * @return
     */
    public static <T, U> U getInsert(T key, Map<T, U> map, Supplier<U> onNull) {
        var value = map.get(key);
        if (value == null) {
            value = onNull.get();
            map.put(key, value);
        }
        return value;
    }

    /**
     * Is equivalent to: {@code get(key, attrs, (U) null); }
     * 
     * @see #get(Object, Map, Supplier)
     * @param key
     * @param attrs
     * @return
     */
    public static <T, U> U get(T key, Map<T, ?> attrs) {
        return get(key, attrs, (U) null);
    }

    /**
     * Is equivalent to: {@code get(key, attrs, () -> def);}
     * 
     * @see #get(Object, Map, Supplier)
     * 
     * @param key
     * @param attrs
     * @param def
     * @return
     */
    public static <T, U> U get(T key, Map<T, ?> attrs, U def) {
        return get(key, attrs, () -> def);
    }

    /**
     * Returns the element with a given key from a given map. If the element doesn't exist or is
     * null, it is created by means of a given Supplier and returned afterwards. In contrast to
     * {@link #getInsert(Object, Map, Supplier)}, the newly created element is NOT inserted into the
     * map.
     * 
     * @param key
     * @param map
     * @param def is called when the element is null or doesn't exist, not null.
     * @return
     */
    @SuppressWarnings("unchecked")
    public static <T, U> U get(T key, Map<T, ?> map, Supplier<U> def) {
        Object obj = map.get(key);
        try {
            if (obj != null) {
                return (U) obj;
            } else {
                return def.get();
            }
        } catch (ClassCastException e) {
            throw new IllegalArgumentException("Cannot convert attribute " + obj + " of type "
                                               + obj.getClass().getSimpleName());
        }
    }

    /**
     * Returns the element with a given key from a given map. If the element exists, it is
     * additionally removed from the map.. If the element doesn't exist or is null, it is created by
     * means of a given Supplier and returned afterwards. In contrast to
     * {@link #getInsert(Object, Map, Supplier)}, the newly created element is NOT inserted into the
     * map.
     * 
     * @param key
     * @param map
     * @param def is called when the element is null or doesn't exist, not null.
     * @return
     */
    @SuppressWarnings("unchecked")
    public static <T> T remove(Object key, Map<?, ?> attrs, Supplier<T> def) {
        Object obj = attrs.remove(key);
        try {
            if (obj != null) {
                return (T) obj;
            } else {
                return def.get();
            }
        } catch (ClassCastException e) {
            throw new IllegalArgumentException("Cannot convert attribute " + obj + " of type "
                                               + obj.getClass().getSimpleName());
        }
    }

    /**
     * Creates a map out of two arrays of equal length. The elements are grouped by their index,
     * i.e., the value with index {@code i} is retrieved by the key with index {@code i}. If
     * {@code keys} contain duplicate keys, the one with higher index is preferred. The
     * {@code values} contains null-values, these are inserted without an error.
     * 
     * @param keys   the array of keys, not null
     * @param values the array of values, not null
     * @return
     * @throws IllegalArgumentException is any of the input arrays are null or they are not of equal
     *                                  length
     */
    public static <T, V> Map<T, V> makeMap(T[] keys, V[] values) {
        if (keys == null || values == null) {
            throw new IllegalArgumentException("Keys and values must both be not null");
        }
        if (keys.length != values.length) {
            throw new IllegalArgumentException("Keys and values must be of the same length! Keys has length "
                                               + keys.length + "; values: " + values.length);
        }
        var map = new HashMap<T, V>();
        for (int i = 0; i < keys.length; i++) {
            map.put(keys[i], values[i]);
        }
        return map;
    }

    /**
     * Returns a new (modifiable) {@code HashMap} containing only those entries from the original
     * {@code Map} whose keys match a given pattern.
     * 
     * @param map
     * @param pattern
     * @return
     */
    public static <V> Map<String, V> filter(Map<String, V> map, Pattern pattern) {
        return filter(map, Algorithms.ignore2(pattern.asMatchPredicate()));
    }

    /**
     * Returns a new (modifiable) {@code HashMap} containing only those entries from the original
     * {@code Map} which satisfy a given {@code BiPredicate}.
     * 
     * @param map  the original Map, not null
     * @param pred the BiPredicate accepting the entry's key as the first and the value as the
     *             second argument. Null returns a copy of the original Map.
     * @return
     */
    public static <K, V> Map<K, V> filter(Map<K, V> map, BiPredicate<? super K, ? super V> pred) {
        return filterInto(map, pred, new HashMap<>());
    }

    /**
     * Puts all entries from a given {@link Map} which satisfy a given {@code BiPredicate} into a
     * given result {@link Map} and returns the latter (for convenience).
     * 
     * @param map    the original Map, not null
     * @param pred   the BiPredicate accepting the entry's key as the first and the value as the
     *               second argument. Null returns a copy of the original Map.
     * @param result the map to put filtered entries into, not null
     * @return
     */
    public static <K, V> Map<K, V> filterInto(Map<K, V> map,
                                              BiPredicate<? super K, ? super V> pred,
                                              Map<K, V> result) {
        if (pred == null) {
            pred = (a, b) -> true;
        }
        for (Map.Entry<K, V> e : map.entrySet()) {
            if (pred.test(e.getKey(), e.getValue())) {
                result.put(e.getKey(), e.getValue());
            }
        }
        return result;
    }

    /**
     * Returns a new (modifiable) Map with keys modified by the {@code keyMapper} and the same
     * values as in the original. If two initially different keys are mapped to the same key, the
     * one inserted later is retained.
     * 
     * @param map       the original map, not null
     * @param keyMapper the mapper, not null
     * @return If the original Map is a {@link NavigableMap}, the returned map is
     *         {@code TreeMap},too. Otherwise, the result is a {@link HashMap}.
     */
    public static <T, W, U> Map<W, U> mapKeys(Map<T, U> map, Function<T, W> keyMapper) {
        return mapKeysValues(map, keyMapper, v -> v);
    }

    /**
     * Returns a new (modifiable) Map with values modified by the {@code valueMapper} and the same
     * values as in the original. The modified values are allowed to be null.
     * 
     * @param map         the original map, not null
     * @param valueMapper the value mapper, not null
     * @return If the original is null, null is returned. If the original is a {@link NavigableMap},
     *         the returned map is {@code TreeMap},too. Otherwise, the result is a {@link HashMap}.
     */
    public static <T, U, V> Map<T, V> mapValues(Map<T, U> map, Function<U, V> valueMapper) {
        return mapKeysValues(map, k -> k, valueMapper);
    }

    public static <T, U, V, W> Map<V, W> mapKeysValues(Map<T, U> map,
                                                       Function<T, V> keyMapper,
                                                       Function<U, W> valueMapper) {
        Map<V, W> result = map instanceof NavigableMap ? new TreeMap<>() : new HashMap<>();

        for (Map.Entry<T, U> e : map.entrySet()) {
            result.put(keyMapper.apply(e.getKey()), valueMapper.apply(e.getValue()));
        }
        return result;

    }

    public static <T, U extends Number> double sum(Iterable<? extends T> elems,
                                                   Function<T, U> converter) {
        return Algorithms.reduce(converter.andThen(Number::doubleValue),
                                 (m, p) -> m + converter.apply(p).doubleValue(),
                                 elems);
    }

    public static <T, U extends Number> double ave(Collection<? extends T> elems,
                                                   Function<T, U> converter) {
        return sum(elems, converter) / elems.size();
    }

    public static <T extends Comparable<T>> T min(boolean nullIsMin, T value1, T value2) {
        if (value1 == null || value2 == null) {
            if (nullIsMin) {
                return null;
            } else {
                return value1 == null ? value2 : value1;
            }
        }
        return value1.compareTo(value2) < 0 ? value1 : value2;
    }

    public static <T extends Comparable<T>> T min(boolean nullIsMin, Iterable<T> values) {
        return Algorithms.reduce(d -> d, (d1, d2) -> min(nullIsMin, d1, d2), values);
    }

    public static <T extends Comparable<T>> T max(boolean nullIsMax, T value1, T value2) {
        if (value1 == null || value2 == null) {
            if (nullIsMax) {
                return null;
            } else {
                return value1 == null ? value2 : value1;
            }
        }
        return value1.compareTo(value2) < 0 ? value2 : value1;
    }

    public static <T extends Comparable<T>> T max(boolean nullIsMax, Iterable<T> values) {
        return Algorithms.reduce(d -> d, (d1, d2) -> max(nullIsMax, d1, d2), values);
    }

    @SafeVarargs
    public static <K extends Comparable<K>, V> KeyValue<K, V> minPair(boolean nullIsMin,
                                                                      Function<V, K> transform,
                                                                      V... elems) {
        assert elems.length > 0 : "There must be at least one element to compare";
        K key = transform.apply(elems[0]);
        int index = 0;
        for (int i = 1; i < elems.length; ++i) {
            key = min(nullIsMin, key, transform.apply(elems[i]));
            index = i;
        }
        return KeyValue.KVP(key, elems[index]);
    }

    ///// ********** Array Converters/Unboxers ************ /////
    public static double[] arrayDouble(Collection<? extends Number> source) {
        double[] result = new double[source.size()];

        int i = 0;
        for (var d : source) {
            result[i++] = d.doubleValue();
        }
        return result;
    }

    public static int[] arrayInt(Collection<? extends Number> source) {
        int[] result = new int[source.size()];

        int i = 0;
        for (var d : source) {
            result[i++] = d.intValue();
        }
        return result;
    }

    public static List<Double> list(double[] array) {
        return DoubleStream.of(array).boxed().collect(Collectors.toList());
    }

    public static List<List<Double>> list(double[][] matrix) {
        List<List<Double>> result = new ArrayList<>();
        for (int i = 0; i < matrix.length; ++i) {
            double[] row = matrix[i];
            List<Double> rowList = new ArrayList<>();
            for (int j = 0; j < row.length; ++j) {
                rowList.add(row[j]);
            }
            result.add(rowList);
        }
        return result;
    }

    public static List<Integer> list(int[] array) {
        return IntStream.of(array).boxed().collect(Collectors.toList());
    }

    ///// ************ Miscellaneous Helpers ************** /////
    /**
     * Returns a symmetric difference of two sets, i.e. a set containing elements from either
     * {@code s1} or {@code s2} but filters out those that lie in both sets. The original sets are
     * left unmodified.
     * 
     * @param s1 one of the original collections, not null
     * @param s2 another original collection, not null
     * @return
     */
    public static <T> Set<T> symmDiff(final Collection<? extends T> s1,
                                      final Collection<? extends T> s2) {
        Set<T> symmetricDiff = new HashSet<T>(s1);
        symmetricDiff.addAll(s2);
        Set<T> tmp = new HashSet<T>(s1);
        tmp.retainAll(s2);
        symmetricDiff.removeAll(tmp);
        return symmetricDiff;
    }

    /**
     * Returns an intersection of multiple collections, i.e., a set containing elements contained in
     * all given collections. The original collections are left unmodified.
     * 
     * @param collections an array of one or more collections to compute the intersection over
     * @return
     * @throws IllegalArgumentException if `collections` is empty
     */
    @SafeVarargs
    public static <T> Set<T> intersection(Collection<T>... collections) {
        return intersection(asList(collections));
    }

    public static <T> Set<T> intersection(Iterable<? extends Collection<T>> collections) {
        // sort by the size (smallest first) to improve memory efficiency: the resulting set
        // is at most as large as the smallest from the incoming collections
        var sorted = list(collections);
        sorted.sort((c1, c2) -> Integer.compare(c1.size(), c2.size()));

        return reduce(i -> set(i, null), (e, i) -> {
            Set<T> result = new HashSet<>();

            // lookups are O(1) in a set and as high as O(n) in a generic collection. So iterate
            // over the incoming collection
            // and lookup in the existing set obtained from the previous steps.
            // It is better to have 2*O(n) than O(n^2).
            for (T incoming : i) {
                if (e.contains(incoming)) {
                    result.add(incoming);
                }
            }
            return result;
        }, sorted);
    }

    public static <T> Collection<T> collection(Iterable<T> source) {
        if (source instanceof Collection) {
            return (Collection<T>) source;
        } else {
            return list(source);
        }
    }

    /**
     * Returns a union of all given iterables, i.e., a set containing elements contained in at least
     * one of given {@link Iterable}s. The original iterables are left unmodified.
     * 
     * @param iterables an array of given Iterables to compute the union over
     * @return @
     * @throws IllegalArgumentException if `iterables` is empty
     */
    @SafeVarargs
    public static <T> Set<T> union(Iterable<T>... iterables) {
        return union(asList(iterables));
    }

    public static <T> Set<T> union(Iterable<? extends Iterable<T>> sequence) {
        return reduce(i -> new HashSet<>(collection(i)), (s, i) -> {
            s.addAll(collection(i));
            return s;
        }, sequence);
    }

    /**
     * Converts given elements into a {@link Set}. There are no guarantees on the type, mutability,
     * serialisability, or thread-safety of the {@code Set} returned.
     * 
     * @see Collectors#toSet()
     * @param elems
     * @return
     */
    @SafeVarargs
    public static <T> Set<T> asSet(T... elems) {
        return Stream.of(elems).collect(Collectors.toSet());
    }

    /**
     * Returns true if either both elements are null or {@code o1}'s method {@code equals} returns
     * true when called with {@code o2} as the argument.
     * 
     * @param o1
     * @param o2
     * @return
     */
    public static boolean isEqualOrNull(Object o1, Object o2) {
        return (o1 == null && o1 == o2) || (o1 != null && o1.equals(o2));
    }

    /**
     * Creates a Class-object corresponding to a List of generic type {@code T}.
     * 
     * @return
     */
    @SuppressWarnings({ "unchecked", "rawtypes" })
    public static <T> Class<List<T>> listClass() {
        return (Class) new ArrayList<T>().getClass();
    }

    @SafeVarargs
    public static <T> T[] merge(boolean swap, T[] arr, T... moreElements) {
        if (moreElements == null || moreElements.length == 0) {
            return arr;
        }
        var prefixElems = swap ? moreElements : arr;
        var suffixElems = swap ? arr : moreElements;

        var result = Arrays.copyOf(prefixElems, arr.length + moreElements.length);
        arraycopy(arr, 0, result, prefixElems.length, suffixElems.length);
        return result;
    }

}
