package ms.ipp;

import static java.lang.System.arraycopy;
import static ms.ipp.Algorithms.reduce;
import static ms.ipp.Algorithms.toKV;
import static ms.ipp.Streams.stream;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.NavigableMap;
import java.util.Set;
import java.util.Spliterator;
import java.util.Spliterators;
import java.util.TreeMap;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.BiPredicate;
import java.util.function.BinaryOperator;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.function.Supplier;
import java.util.regex.Pattern;
import java.util.stream.Collector;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import ms.ipp.iterable.BiIterable;
import ms.ipp.iterable.FilteredIterable;
import ms.ipp.iterable.MappedIterable;
import ms.ipp.iterable.ProxyBiIterable;
import ms.ipp.iterator.FilteredIterator;

/**
 * @author saienko
 * 
 */
public class Iterables {
	/**
	 * A No-Op
	 */
	public static Runnable NULL_CALL = () -> {
	};

	///////////////////////////////////////////////////////
	/// *********** BiIterable Manipulation *********** ///
	///////////////////////////////////////////////////////

	/**
	 * Returns a {@code BiIterable} which maps all elements from the original
	 * {@code BiIterable} by means of a given mapping function.
	 * 
	 * @param it
	 * @param map
	 * @return
	 */
	public static <T, U, V, W> BiIterable<V, W> mapped(BiIterable<T, U> it,
			BiFunction<? super T, ? super U, Entry<V, W>> map) {
		return toBiIt(mapped(removeProxies(it), toKV(map)));
	}

	/**
	 * Returns a {@code BiIterable} which contains only those elements from the
	 * original {@code BiIterable} which satisfy a given {@code BiPredicate}.
	 * 
	 * @param it
	 * @param pred
	 * @return
	 */
	public static <T, U> BiIterable<T, U> filtered(BiIterable<T, U> it,
			BiPredicate<? super T, ? super U> pred) {
		return pred == null ? it : toBiIt(filtered(removeProxies(it), toKV(pred)));
	}

	/**
	 * Returns a {@code BiIterable} which contains elements with distinct keys. The
	 * key for each element is generated by a given {@code BiFunction}.
	 * 
	 * @param it
	 * @param keyExtractor the {@code BiFunction} which generates keys for elements
	 * @return
	 */
	public static <T, U> BiIterable<T, U> distinct(BiIterable<T, U> it,
			BiFunction<? super T, ? super U, ?> keyExtractor) {
		return toBiIt(distinct(removeProxies(it), toKV(keyExtractor)));
	}

	/**
	 * Returns a {@code BiIterable} which calls a given {@code BiConsumer} prior to
	 * deleting an element. The element is passed to hook as the first and the only
	 * argument.
	 * 
	 * @param it
	 * @param onDelete
	 * @return
	 */
	public static <T, U> BiIterable<T, U> deleteHook(BiIterable<T, U> it,
			BiConsumer<? super T, ? super U> onDelete) {
		return toBiIt(deleteHook(removeProxies(it), toKV(onDelete)));
	}

	/**
	 * Returns true if all elements in the {@code BiIterable} satisfy a given
	 * {@code BiPredicate}.
	 * 
	 * @param it   the original BiIterable, not null
	 * @param pred the predicate. If null, true is returned.
	 * @return
	 */
	public static <T, U> boolean all(BiIterable<T, U> it, BiPredicate<? super T, ? super U> pred) {
		return all(it, toKV(pred));
	}

	/**
	 * Returns true if none of the elements in the {@code BiIterable} satisfy a
	 * given {@code BiPredicate}.
	 * 
	 * @param it   the original BiIterable, not null
	 * @param pred the predicate. If null, returns true is the BiIterable is empty
	 * @return
	 */
	public static <T, U> boolean none(BiIterable<T, U> it, BiPredicate<? super T, ? super U> pred) {
		return none(it, toKV(pred));
	}

	/**
	 * Returns true if at least one of the elements in the {@code BiIterable}
	 * satisfies a given {@code BiPredicate}.
	 * 
	 * @param it   the original BiIterable, not null
	 * @param pred the predicate. If null, returns true if the BiIterable is not
	 *             empty
	 * @return
	 */
	public static <T, U> boolean any(BiIterable<T, U> it, BiPredicate<? super T, ? super U> pred) {
		return any(it, toKV(pred));
	}

	/**
	 * If there is exactly one item in the {@code BiIterable} which satisfies a
	 * given {@code BiPredicate}, returns the element. If there are no items
	 * satisfying the {@code Predicate}, returns null. If there are more than one
	 * items, throws {@link IllegalArgumentException}.
	 * 
	 * @param it   the original BiIterable, not null
	 * @param pred the predicate, null is interpreted as a condition which always
	 *             returns true.
	 * @return
	 */
	public static <T, U> Entry<T, U> unique(BiIterable<T, U> it,
			BiPredicate<? super T, ? super U> pred) {
		return unique(it, toKV(pred));
	}

	/**
	 * Returns the first element encountered in the {@code BiIterable} which
	 * satisfies a given {@code BiPredicate}.
	 * 
	 * @param it   the original BiIterable, not null
	 * @param pred the predicate, null is interpreted as a condition which always
	 *             returns true
	 * @return
	 */
	public static <T, U> Entry<T, U> first(BiIterable<T, U> it,
			BiPredicate<? super T, ? super U> pred) {
		return first(it, toKV(pred));
	}

	/**
	 * Performs a given action on all elements from the {@code BiIterable}.
	 * 
	 * @param it   the original BiIterable, not null
	 * @param proc the action to perform on eligible elements, not null
	 * @return
	 */
	public static <T, U> void forEach(BiIterable<T, U> it, BiConsumer<? super T, ? super U> proc) {
		forEach(it, toKV(proc));
	}

	/**
	 * Removes all elements from the {@code BiIterable} which satisfy a given
	 * {@code BiPredicate}.
	 * 
	 * @param it   the original BiIterable, not null
	 * @param pred the predicate. If null, all elements will be removed
	 * @return true if at least one element has been removed
	 */
	public static <T, U> boolean removeFrom(BiIterable<T, U> it,
			BiPredicate<? super T, ? super U> pred) {
		return removeFrom(it, toKV(pred));
	}

	/**
	 * Collects all elements from the {@code BiIterable} which satisfy a given
	 * {@code BiPredicate} to a {@code List}.
	 * 
	 * @param st   the original BiIterable, not null
	 * @param pred the predicate. If null, the original BiIterable is used
	 * @return
	 */
	public static <T, U> List<Entry<T, U>> list(BiIterable<T, U> it,
			BiPredicate<? super T, ? super U> pred) {
		return list(it, toKV(pred));
	}

	/**
	 * Converts a given {@code Iterable<Entry<T,U>>} to a {@code BiIterable<T,U>}.
	 * 
	 * @param it the original Iterable. Null returns null. If the source is already
	 *           BiIterable, it is returned unchanged.
	 * @return
	 */
	@SuppressWarnings("unchecked")
	public static <T, U> BiIterable<T, U> toBiIt(Iterable<? extends Entry<T, U>> it) {
		if (it == null) {
			return null;
		} else if (it instanceof BiIterable) {
			return (BiIterable<T, U>) it;
		} else {
			return new ProxyBiIterable<>((Iterable<Entry<T, U>>) it);
		}
	}

	@SuppressWarnings("unchecked")
	private static <T, U> Iterable<Entry<T, U>> removeProxies(Iterable<Entry<T, U>> source) {
		while (source instanceof ProxyBiIterable) {
			source = ((ProxyBiIterable<T, U>) source).getSource();
		}
		return source;
	}
	///////////////////////////////////////////////////////
	/// ************ Iterable Manipulation ************ ///
	///////////////////////////////////////////////////////

	/**
	 * Returns an {@code Iterable} which maps all elements from the original
	 * {@code Iterable} by means of a given mapping function.
	 * 
	 * @param it
	 * @param map
	 * @return
	 */
	public static <T, U> Iterable<U> mapped(Iterable<T> it, Function<? super T, U> map) {
		return new MappedIterable<>(it, map);
	}

	private static <T> Iterable<T> filtered(Iterable<T> it, Supplier<Predicate<? super T>> filter) {
		return filter == null ? it : new FilteredIterable<>(it).setFilter(filter);
	}

	/**
	 * Returns an {@code Iterable} which contains only those elements from the
	 * original {@code Iterable} which satisfy a given {@code Predicate}.
	 * 
	 * @param it
	 * @param pred
	 * @return
	 */
	public static <T> Iterable<T> filtered(Iterable<T> it, Predicate<? super T> pred) {
		return pred == null ? it : filtered(it, () -> pred);
	}

	/**
	 * Returns an {@code Iterable} which contains elements with distinct keys. The
	 * key for each element is generated by a given {@code Function}.
	 * 
	 * @param it
	 * @param keyExtractor the {@code Function} which generates keys for elements
	 * @return
	 */
	public static <T> Iterable<T> distinct(Iterable<T> it, Function<? super T, ?> keyExtractor) {
		// we only return a predicate-supplier. Otherwise, the "seen" set in the
		// distinctByKey-method would be instantiated now and not upon calling
		// the iterator()-method
		return filtered(it, () -> FilteredIterator.distinctByKey(keyExtractor));
	}

	/**
	 * Returns an {@code Iterable} which calls a given {@code Consumer} prior to
	 * deleting an element. The element is passed to hook as the first and the only
	 * argument.
	 * 
	 * @param it
	 * @param onDelete
	 * @return
	 */
	public static <T> Iterable<T> deleteHook(Iterable<T> source, Consumer<? super T> onDelete) {
		return onDelete == null ? source : new FilteredIterable<>(source).setOnDelete(onDelete);
	}

	/**
	 * Returns true if all elements in the {@code Iterable} satisfy a given
	 * {@code Predicate}.
	 * 
	 * @param it   the original Iterable, not null
	 * @param pred the predicate. If null, true is returned.
	 * @return
	 */
	public static <T> boolean all(Iterable<T> it, Predicate<? super T> pred) {
		return Streams.all(stream(it), pred);
	}

	/**
	 * Returns true if none of the elements in the {@code Iterable} satisfy a given
	 * {@code Predicate}.
	 * 
	 * @param it   the original Iterable, not null
	 * @param pred the predicate. If null, returns true is the Iterable is empty
	 * @return
	 */
	public static <T> boolean none(Iterable<T> it, Predicate<? super T> pred) {
		return Streams.none(stream(it), pred);
	}

	/**
	 * Returns true if at least one of the elements in the {@code Iterable}
	 * satisfies a given {@code Predicate}
	 * 
	 * @param it   the original Iterable, not null
	 * @param pred the predicate. If null, returns true if the Iterable is not
	 *             empty.
	 * @return
	 */
	public static <T> boolean any(Iterable<T> it, Predicate<? super T> pred) {
		return Streams.any(stream(it), pred);
	}

	/**
	 * If there is exactly one item in the {@code Iterable} which satisfies a given
	 * {@code Predicate}, returns the element. If there are no items satisfying the
	 * {@code Predicate}, returns null. If there are more than one items, throws
	 * {@link IllegalArgumentException}.
	 * 
	 * @param it
	 * @param pred
	 * @return
	 */
	public static <T> T unique(Iterable<T> it, Predicate<? super T> pred) {
		return Streams.unique(stream(it), pred);
	}

	/**
	 * Returns the first element encountered in the {@code Iterable} which satisfies
	 * a given {@code Predicate}.
	 * 
	 * @param it   the original Iterable, not null
	 * @param pred the predicate, null is interpreted as a condition which always
	 *             returns true
	 * @return
	 */
	public static <T> T first(Iterable<T> it, Predicate<? super T> pred) {
		return Streams.first(stream(it), pred);
	}

	/**
	 * Performs a given action on all elements from the {@code Iterable}.
	 * 
	 * @param it   the original Iterable, not null
	 * @param proc the action to perform on eligible elements, not null
	 * @return
	 */
	public static <T> void forEach(Iterable<T> it, Consumer<? super T> proc) {
		// we don't have to create streams for this
		if (it != null) {
			it.forEach(proc);
		}
	}

	/**
	 * Removes all elements from the {@code Iterable} which satisfy a given
	 * {@code Predicate}.
	 * 
	 * @param it   the original Iterable, not null
	 * @param pred the predicate. If null, all elements will be removed
	 * @return true if at least one element has been removed
	 */
	public static <T> boolean removeFrom(Iterable<T> it, Predicate<? super T> pred) {
		boolean removed = false;
		Iterator<T> itr = it.iterator();
		if (pred == null) {
			pred = t -> true;
		}
		while (itr.hasNext()) {
			if (pred.test(itr.next())) {
				itr.remove();
				removed = true;
			}
		}
		return removed;
	}

	/**
	 * Returns the number of elements in a given {@code Iterable}
	 * 
	 * @param it
	 * @return
	 */
	public static <T> int count(Iterable<T> it) {
		return list(it).size();
	}

	/**
	 * Collects all elements from the {@code Iterable} to a {@code List}.
	 * 
	 * @param it the original BiIterable, not null
	 * @return
	 */
	public static <T, U extends T> List<T> list(Iterable<U> it) {
		return list(it, null);
	}

	/**
	 * Collects all elements from the {@codeIterable} which satisfy a given
	 * {@code BiPredicate} to a {@code List}.
	 * 
	 * @param it   the original Iterable, not null
	 * @param pred the predicate. If null, the original Iterable is used
	 * @return
	 */
	public static <T, U extends T> List<T> list(Iterable<U> it, Predicate<? super U> pred) {
		return Streams.list(stream(it), pred);
	}

	/**
	 * Collects all elements from the {@code Iterable} which satisfy a given
	 * {@code BiPredicate} to a {@code Set}.
	 * 
	 * @param it   the original Iterable, not null
	 * @param pred the predicate. If null, the original Iterable is used
	 * @return
	 */
	public static <T, U extends T> Set<T> set(Iterable<U> it, Predicate<? super U> pred) {
		return Streams.set(stream(it), pred);
	}

	/**
	 * Collects all elements from the {@code Iterable<Entry<T,U>>} a
	 * {@code Map<T,U>}.
	 * 
	 * @param it
	 * @return
	 */
	public static <T, U> Map<T, U> map(Iterable<? extends Entry<T, U>> it) {
		return collect(it, null, Collectors.toMap(e -> e.getKey(), e -> e.getValue()));
	}

	public static <T, U> Map<T, U> toHashMap(Iterable<? extends U> it,
			Function<? super U, T> keyGen) {
		return collect(it, null, Collectors.toMap(keyGen::apply, e -> e));
	}

	public static <T, U> TreeMap<T, U> toTreeMap(Iterable<? extends U> it,
			Function<? super U, T> keyGen) {
		return toTreeMap(it, keyGen, e -> e);
	}

	public static <T, U, V> TreeMap<T, V> toTreeMap(Iterable<? extends U> it,
			Function<? super U, T> keyGen, Function<? super U, V> valueGen) {
		return collect(it, null, toTreeMap(keyGen, valueGen));
	}

	private static <T> BinaryOperator<T> throwingMerger() {
		return (u, v) -> {
			throw new IllegalStateException(String.format("Duplicate key %s", u));
		};
	}

	public static <T, K, U> Collector<T, ?, TreeMap<K, U>> toTreeMap(
			Function<? super T, ? extends K> keyMapper,
			Function<? super T, ? extends U> valueMapper) {
		// Adapted from Collectors.toMap(keyMapper, valueMapper)
		return Collectors.toMap(keyMapper, valueMapper, throwingMerger(), TreeMap::new);
	}

	/**
	 * Collects all elements from the {@code Iterable} which satisfy a given
	 * {@code Predicate} by using a given {@link Collector}.
	 * 
	 * @param st        the original Iterable, not null
	 * @param pred      the predicate. If null, the original Iterable is used
	 * @param collector the Collector, as it is used by @{code Stream::collect}
	 *                  methods
	 */
	public static <T, R> R collect(Iterable<T> it, Predicate<? super T> pred,
			Collector<T, ?, R> collector) {
		return Streams.collect(stream(it), pred, collector);
	}

	/**
	 * Collects at most the first {@code n} elements from the {@code Iterable} which
	 * satisfy a given {@code Predicate} by using a given {@link Collector}.
	 * 
	 * @param st        the original Iterable, not null
	 * @param pred      the predicate. If null, the original Iterable is used
	 * @param collector the Collector, as it is used by @{code Stream::collect}
	 *                  methods.
	 * @param n         the number of elements to collect
	 */
	public static <T, R> R collect(Iterable<T> it, Predicate<? super T> pred,
			Collector<T, ?, R> collector, int n) {
		return Streams.collect(stream(it), pred, collector, n);
	}

	/**
	 * Creates and returns an {@link Iterable} from a given supplier of iterators.
	 * 
	 * @param it
	 * @return
	 */
	public static <T> Iterable<T> toIterable(Supplier<Iterator<T>> it) {
		return toIterable(it, 0);
	}

	/**
	 * Creates and returns an {@link Iterable} with given characteristics from a
	 * given supplier of iterators.
	 * 
	 * @param it
	 * @return
	 */
	public static <T> Iterable<T> toIterable(Supplier<Iterator<T>> it, int chars) {
		Iterable<T> itr = new Iterable<T>() {
			@Override
			public Iterator<T> iterator() {
				return it.get();
			}

			@Override
			public Spliterator<T> spliterator() {
				return Spliterators.spliteratorUnknownSize(iterator(), chars);
			}
		};
		return itr;
	}

	///// ************** Shortcuts for Collections ***************** /////
	/**
	 * Returns a {@code List} containing all elements from the original
	 * {@code Collection} transformed by means of a given mapping {@code Function}.
	 * 
	 * @param items
	 * @param map
	 * @return
	 */
	public static <T, U> List<U> map(Iterable<T> items, Function<T, U> map) {
		return mapFilter(items, map, null);
	}

	/**
	 * Returns a {@code List} containing all elements inserted by a given
	 * {@code parser} after applying it to every element in a given
	 * {@code Collection}. Any exceptions thrown by the {@code parser} are converted
	 * to {@link IllegalArgumentException}.
	 * 
	 * @param items  the original collection, not null
	 * @param parser the BiConsumer which decides how to populate the resulting
	 *               list, not null
	 * @return
	 * @throws IllegalArgumentException if items is null or parser throws.
	 */
	public static <S, T> List<T> parseList(Collection<S> items, BiConsumer<S, List<T>> parser) {
		if (items == null) {
			throw new IllegalArgumentException("Can not convert a null list");
		}
		List<T> result = new ArrayList<>();
		for (S s : items) {
			try {
				parser.accept(s, result);
			} catch (Exception e) {
				throw new IllegalArgumentException("Parameter list " + items + " cannot be parsed");
			}
		}
		return result;
	}

	/**
	 * Filters out all elements from the original {@code Collection} that do not
	 * satisfy a given {@code Predicate} and returns a {@code List} containing all
	 * elements from the filtered {@code Collection} transformed by means of a given
	 * mapping {@code Function}.
	 * 
	 * @param items
	 * @param map
	 * @return
	 */
	public static <T, U> List<U> filterMap(Iterable<T> items, Predicate<T> pred,
			Function<T, U> mapper) {
		return Streams.list(Streams.mapped(Streams.filtered(stream(items), pred), mapper), null);
	}

	/**
	 * Returns a {@code List} containing only elements from the original
	 * {@code Collection} which are transformed by means of a given mapping
	 * {@code Function} and additionally satisfy a given {@code Predicate} for the
	 * transformed values.
	 * 
	 * @param items
	 * @param map
	 * @param pred
	 * @return
	 */
	public static <T, U> List<U> mapFilter(Iterable<T> items, Function<T, U> map,
			Predicate<U> pred) {
		return Streams.list(Streams.mapped(stream(items), map), pred);
	}

	/**
	 * Returns the number of elements in a given {@code Collection}.
	 * 
	 * @param items
	 * @return
	 */
	public static <T> int count(Collection<T> items) {
		return items.size();
	}

	///// ************ Shortcuts for Collection serializing ************** /////
	/**
	 * Serialises an array by interlacing all elements with ','.
	 * 
	 * @param array the source array, not null
	 * @return
	 */
	public static <T> String toString(T[] array) {
		StringBuffer buf = new StringBuffer(500);
		appendList(buf, Arrays.asList(array));
		return buf.toString();
	}

	/**
	 * Is equivalent to:
	 * 
	 * <pre>
	 * appendList(buf, items, "[", "]", ", ", (t, b) -> b.append(t.toString()));
	 * </pre>
	 * 
	 * @param buf   the StringBuffer to add the serialised Collection to, not null
	 * @param items the original Collection, not null
	 * 
	 */
	public static void appendList(StringBuffer buf, Collection<?> items) {
		appendList(buf, items, (t, b) -> b.append(t.toString()));
	}

	/**
	 * Is equivalent to:
	 * 
	 * <pre>
	 * appendList(buf, items, "[", "]", ", ", serializer);
	 * </pre>
	 * 
	 * @param buf        the StringBuffer to add the serialised Collection to, not
	 *                   null
	 * @param items      the original Collection, not null
	 * @param serializer a BiConsumer which should add to a StringBuffer the
	 *                   serialised version on the element passed, not null
	 */
	public static <T> void appendList(StringBuffer buf, Collection<? extends T> items,
			BiConsumer<T, StringBuffer> serializer) {
		appendList(buf, items, "[", "]", ", ", serializer);
	}

	/**
	 * Serialises a {@code Collection} by using a given opening string, a given
	 * closing string, a given separator as well as a given serialiser for each
	 * element in the {@code Collection} and adds the serialised content to a given
	 * {@code StringBuffer}.
	 * 
	 * @param buf        the StringBuffer to add the serialised Collection to, not
	 *                   null
	 * @param items      the original Collection, not null
	 * @param op         the string which is prepended to the serialised Collection,
	 *                   not null
	 * @param cl         the string added to the serialised Collection at the end,
	 *                   not null
	 * @param sep        the string to mark the two elements as separate, not null
	 * @param serializer a BiConsumer which should add to a StringBuffer the
	 *                   serialised version on the element passed, not null
	 */
	public static <T> void appendList(StringBuffer buf, Collection<? extends T> items, String op,
			String cl, String sep, BiConsumer<T, StringBuffer> serializer) {
		buf.append(op);

		for (T t : items) {
			serializer.accept(t, buf);
			buf.append(sep);
		}

		if (items.size() >= 1) {
			buf.delete(buf.length() - sep.length(), buf.length());
		}
		buf.append(cl);
	}

	/**
	 * Serialises a {@code Collection} by using a given opening string, a given
	 * closing string, a given separator as well as a given serialiser for each
	 * element in the {@code Collection} and returns the serialised content.
	 * Internally, it creates an interim {@link StringBuffer}, calls
	 * {@link #appendList(StringBuffer, Collection, String, String, String, BiConsumer)}
	 * and returns the buffer's content.
	 * 
	 * @param items      the original Collection, not null
	 * @param op         the string which is prepended to the serialised Collection,
	 *                   not null
	 * @param cl         the string added to the serialised Collection at the end,
	 *                   not null
	 * @param sep        the string to mark the two elements as separate, not null
	 * @param serializer a BiConsumer which should add to a StringBuffer the
	 *                   serialised version on the element passed, not null
	 * @return
	 */
	public static <T> String appendList(Collection<? extends T> items, String op, String cl,
			String sep, BiConsumer<T, StringBuffer> serializer) {
		StringBuffer sb = new StringBuffer(items.size() * 1000);
		appendList(sb, items, op, cl, sep, serializer);
		return sb.toString();
	}

	/**
	 * Serialises a {@code Collection} by using a given opening string, a given
	 * closing string, a given separator as well as a given serialiser for each
	 * element in the {@code Collection} and returns the serialised content. Is
	 * equivalent to:
	 * {@code appendList(items, op, cl, sep, (s, sb) -> sb.append(serializer.apply(s)));}
	 * 
	 * @param items      the original Collection, not null
	 * @param op         the string which is prepended to the serialised Collection,
	 *                   not null
	 * @param cl         the string added to the serialised Collection at the end,
	 *                   not null
	 * @param sep        the string to mark the two elements as separate, not null
	 * @param serializer a Function which generates a serialised version of a
	 *                   collection element passed, not null
	 * @return
	 */
	public static <T> String appendList(Collection<? extends T> items, String op, String cl,
			String sep, Function<T, String> serializer) {
		return appendList(items, op, cl, sep, (s, sb) -> sb.append(serializer.apply(s)));
	}

	///// ************ Shortcuts for Lists ************** /////
	/**
	 * Returns the first index on a given list, for which a given Predicate returns
	 * true. If no elements satisfy the Predicate, returns -1.
	 * 
	 * @param list the original List. Null returns -1.
	 * @param pred the Predicate to test, not null
	 * @return
	 */
	public static <T> int indexOf(List<T> list, Predicate<T> pred) {
		if (list == null) {
			return -1;
		}
		for (int i = 0; i < list.size(); ++i) {
			if (pred.test(list.get(i))) {
				return i;
			}
		}
		return -1;
	}

	/**
	 * Returns the first index starting from the back of a given list, for which a
	 * given Predicate returns true. If no elements satisfy the Predicate, returns
	 * -1.
	 * 
	 * @param list the original List. Null returns -1.
	 * @param pred the Predicate to test, not null
	 * @return
	 */
	public static <T> int lastIndexOf(List<T> list, Predicate<T> pred) {
		if (list == null) {
			return -1;
		}
		for (int i = list.size() - 1; i >= 0; --i) {
			if (pred.test(list.get(i))) {
				return i;
			}
		}
		return -1;
	}

	/**
	 * Returns an array which contains the indexes of the elements of
	 * {@code subList} in {@code totalList}. The order of indexes in the resulting
	 * array correspond to the order of elements in {@code subList}. If any element
	 * from {@code subList} is not found in the {@code totalList}, its index in the
	 * resulting array is to -1.
	 * 
	 * @param totalList the list of all elements. If null, an empty list is used
	 *                  instead
	 * @param subList   the list of elements whose indexes in the {@code totalList}
	 *                  need to be found, not null
	 * @return
	 */
	public static <U> int[] getIndexes(List<U> totalList, List<U> subList) {
		totalList = totalList == null ? new ArrayList<>() : totalList;
		return totalList.stream().mapToInt(s -> subList.indexOf(s)).toArray();
	}

	///// ************ Shortcuts for Maps ************** /////
	/**
	 * Performs a given action on an element with a given key if such element
	 * exists. Is equivalent to:
	 * 
	 * <pre>
	 * ifExistsDo(name, attrs, null, proc);
	 * </pre>
	 * 
	 * @param name  the key of the target element, not null
	 * @param attrs a string-based map with elements, not null
	 * @param proc  the action to be performed on the element with a given key, not
	 *              null.
	 */
	public static <T> void ifExistsDo(String name, Map<String, ? extends Object> attrs,
			Consumer<T> proc) {
		ifExistsDo(name, attrs, null, proc);
	}

	/**
	 * Performs a given action on an element with a given key if such element exists
	 * and is not contained in a given list of elements to be ignored.
	 * 
	 * @param name   the key of the target element, not null
	 * @param attrs  a string-based map with elements, not null
	 * @param ignore a list with keys to be ignored, may be null.
	 * @param proc   the action to be performed on the element with a given key, not
	 *               null.
	 */
	@SuppressWarnings("unchecked")
	public static <T> void ifExistsDo(String name, Map<String, ? extends Object> attrs,
			List<String> ignore, Consumer<T> proc) {
		if (attrs.containsKey(name) && (ignore == null || !ignore.contains(name))) {
			proc.accept((T) attrs.get(name));
		}
	}

	public static <T, U> U ifExistsApply(String name, Map<String, ? extends Object> attrs,
			Function<T, U> func, Supplier<U> onMiss) {
		return ifExistsApply(name, attrs, null, func, onMiss);
	}

	@SuppressWarnings("unchecked")
	public static <T, U> U ifExistsApply(String name, Map<String, ? extends Object> attrs,
			List<String> ignore, Function<T, U> func, Supplier<U> onMiss) {
		if (attrs.containsKey(name) && (ignore == null || !ignore.contains(name))) {
			return func.apply((T) attrs.get(name));
		} else {
			return onMiss == null ? null : onMiss.get();
		}
	}

	/**
	 * Returns the list with a given key from a given map of lists. If the list
	 * doesn't exist or is null, a new empty {@link ArrayList} is inserted into the
	 * map prior to being returned.
	 * 
	 * @param key
	 * @param map
	 * @return
	 */
	public static <T, U> List<U> getInsert(T key, Map<T, List<U>> map) {
		return getInsert(key, map, ArrayList::new);
	}

	/**
	 * Returns the element with a given key from a given map. If the element doesn't
	 * exist or is null, it is created by means of a given Supplier and inserted
	 * into the map prior to being returned.
	 * 
	 * @param key
	 * @param map
	 * @param onNull is called when the element is null or doesn't exist, not null.
	 * @return
	 */
	public static <T, U> U getInsert(T key, Map<T, U> map, Supplier<U> onNull) {
		U value = map.get(key);
		if (value == null) {
			value = onNull.get();
			map.put(key, value);
		}
		return value;
	}

	/**
	 * Is equivalent to: {@code get(key, attrs, (U) null); }
	 * 
	 * @see #get(Object, Map, Supplier)
	 * @param key
	 * @param attrs
	 * @return
	 */
	public static <T, U> U get(T key, Map<T, ?> attrs) {
		return get(key, attrs, (U) null);
	}

	/**
	 * Is equivalent to: {@code get(key, attrs, () -> def);}
	 * 
	 * @see #get(Object, Map, Supplier)
	 * 
	 * @param key
	 * @param attrs
	 * @param def
	 * @return
	 */
	public static <T, U> U get(T key, Map<T, ?> attrs, U def) {
		return get(key, attrs, () -> def);
	}

	/**
	 * Returns the element with a given key from a given map. If the element doesn't
	 * exist or is null, it is created by means of a given Supplier and returned
	 * afterwards. In contrast to {@link #getInsert(Object, Map, Supplier)}, the
	 * newly created element is NOT inserted into the map.
	 * 
	 * @param key
	 * @param map
	 * @param def is called when the element is null or doesn't exist, not null.
	 * @return
	 */
	@SuppressWarnings("unchecked")
	public static <T, U> U get(T key, Map<T, ?> map, Supplier<U> def) {
		Object obj = map.get(key);
		try {
			if (obj != null) {
				return (U) obj;
			} else {
				return def.get();
			}
		} catch (ClassCastException e) {
			throw new IllegalArgumentException("Cannot convert attribute " + obj + " of type "
					+ obj.getClass().getSimpleName());
		}
	}

	/**
	 * Returns the element with a given key from a given map. If the element exists,
	 * it is additionally removed from the map.. If the element doesn't exist or is
	 * null, it is created by means of a given Supplier and returned afterwards. In
	 * contrast to {@link #getInsert(Object, Map, Supplier)}, the newly created
	 * element is NOT inserted into the map.
	 * 
	 * @param key
	 * @param map
	 * @param def is called when the element is null or doesn't exist, not null.
	 * @return
	 */
	@SuppressWarnings("unchecked")
	public static <T> T remove(Object key, Map<?, ?> attrs, Supplier<T> def) {
		Object obj = attrs.remove(key);
		try {
			if (obj != null) {
				return (T) obj;
			} else {
				return def.get();
			}
		} catch (ClassCastException e) {
			throw new IllegalArgumentException("Cannot convert attribute " + obj + " of type "
					+ obj.getClass().getSimpleName());
		}
	}

	/**
	 * Creates a map out of two arrays of equal length. The elements are grouped by
	 * their index, i.e., the value with index {@code i} is retrieved by the key
	 * with index {@code i}. If {@code keys} contain duplicate keys, the one with
	 * higher index is preferred. The {@code values} contains null-values, these are
	 * inserted without an error.
	 * 
	 * @param keys   the array of keys, not null
	 * @param values the array of values, not null
	 * @return
	 * @throws IllegalArgumentException is any of the input arrays are null or they
	 *                                  are not of equal length
	 */
	public static <T, V> Map<T, V> makeMap(T[] keys, V[] values) {
		if (keys == null || values == null) {
			throw new IllegalArgumentException("Keys and values must both be not null");
		}
		if (keys.length != values.length) {
			throw new IllegalArgumentException(
					"Keys and values must be of the same length! Keys has length " + keys.length
							+ "; values: " + values.length);
		}
		Map<T, V> map = new HashMap<T, V>();
		for (int i = 0; i < keys.length; i++) {
			map.put(keys[i], values[i]);
		}
		return map;
	}

	/**
	 * Returns a new (modifiable) {@code HashMap} containing only those entries from
	 * the original {@code Map} whose keys match a given pattern.
	 * 
	 * @param map
	 * @param pattern
	 * @return
	 */
	public static <V> Map<String, V> filter(Map<String, V> map, Pattern pattern) {
		return filter(map, Algorithms.ignore2(pattern.asMatchPredicate()));
	}

	/**
	 * Returns a new (modifiable) {@code HashMap} containing only those entries from
	 * the original {@code Map} which satisfy a given {@code BiPredicate}.
	 * 
	 * @param map  the original Map, not null
	 * @param pred the BiPredicate accepting the entry's key as the first and the
	 *             value as the second argument. Null returns a copy of the original
	 *             Map.
	 * @return
	 */
	public static <K, V> Map<K, V> filter(Map<K, V> map, BiPredicate<? super K, ? super V> pred) {
		Map<K, V> result = new HashMap<>();
		if (pred == null) {
			pred = (a, b) -> true;
		}
		for (Map.Entry<K, V> e : map.entrySet()) {
			if (pred.test(e.getKey(), e.getValue())) {
				result.put(e.getKey(), e.getValue());
			}
		}
		return result;
	}

	/**
	 * Returns a new (modifiable) Map with keys modified by the {@code keyMapper}
	 * and the same values as in the original. If two initially different keys are
	 * mapped to the same key, the one inserted later is retained.
	 * 
	 * @param map       the original map, not null
	 * @param keyMapper the mapper, not null
	 * @return If the original Map is a {@link NavigableMap}, the returned map is
	 *         {@code TreeMap},too. Otherwise, the result is a {@link HashMap}.
	 */
	public static <T, W, U> Map<W, U> mapKeys(Map<T, U> map, Function<T, W> keyMapper) {
		return mapKeysValues(map, keyMapper, v -> v);
	}

	/**
	 * Returns a new (modifiable) Map with values modified by the
	 * {@code valueMapper} and the same values as in the original. The modified
	 * values are allowed to be null.
	 * 
	 * @param map         the original map, not null
	 * @param valueMapper the value mapper, not null
	 * @return If the original is null, null is returned. If the original is a
	 *         {@link NavigableMap}, the returned map is {@code TreeMap},too.
	 *         Otherwise, the result is a {@link HashMap}.
	 */
	public static <T, U, V> Map<T, V> mapValues(Map<T, U> map, Function<U, V> valueMapper) {
		return mapKeysValues(map, k -> k, valueMapper);
	}

	public static <T, U, V, W> Map<V, W> mapKeysValues(Map<T, U> map, Function<T, V> keyMapper,
			Function<U, W> valueMapper) {
		Map<V, W> result = map instanceof NavigableMap ? new TreeMap<>() : new HashMap<>();

		for (Map.Entry<T, U> e : map.entrySet()) {
			result.put(keyMapper.apply(e.getKey()), valueMapper.apply(e.getValue()));
		}
		return result;

	}

	///// ************ Miscellaneous Helpers ************** /////
	/**
	 * Returns a symmetric difference of two sets, i.e. a set containing elements
	 * from either {@code s1} or {@code s2} but filters out those that lie in both
	 * sets. The original sets are left unmodified.
	 * 
	 * @param s1 one of the original collections, not null
	 * @param s2 another original collection, not null
	 * @return
	 */
	public static <T> Set<T> symmDiff(final Collection<? extends T> s1,
			final Collection<? extends T> s2) {
		Set<T> symmetricDiff = new HashSet<T>(s1);
		symmetricDiff.addAll(s2);
		Set<T> tmp = new HashSet<T>(s1);
		tmp.retainAll(s2);
		symmetricDiff.removeAll(tmp);
		return symmetricDiff;
	}

	/**
	 * Returns an intersection of two sets, i.e., a set containing elements
	 * contained in both {@code s1} and {@code s2}. The original sets are left
	 * unmodified.
	 * 
	 * @param s1 one of the original collections, not null
	 * @param s2 another original collection, not null
	 * @return
	 */
	public static <T> List<T> intersection(Collection<T> s1, Collection<T> s2) {
		List<T> result = new ArrayList<T>();
		// lookups are O(1) in a set and O(n) in a list. So convert to a set.
		// It is better to have 2*O(n) than O(n^2).
		Set<T> set2 = new HashSet<>(s2);
		for (T t : s1) {
			if (set2.contains(t)) {
				result.add(t);
			}
		}

		return result;
	}

	public static <T> Collection<T> collection(Iterable<T> source) {
		if (source instanceof Collection) {
			return (Collection<T>) source;
		} else {
			return list(source);
		}
	}

	/**
	 * Returns an intersection of two sets, i.e., a set containing elements
	 * contained in at least one of the sets {@code s1}, {@code s2}. The original
	 * sets are left unmodified.
	 * 
	 * @param s1 one of the original collections, not null
	 * @param s2 another original collection, not null
	 * @return
	 */
	@SafeVarargs
	public static <T> Set<T> union(Iterable<T>... elems) {
		return union(Arrays.asList(elems));
	}

	public static <T> Set<T> union(Iterable<? extends Iterable<T>> sequence) {
		return reduce(i -> new HashSet<>(collection(i)), (s, i) -> {
			s.addAll(collection(i));
			return s;
		}, sequence);
	}

	/**
	 * Converts given elements into a {@link Set}. There are no guarantees on the
	 * type, mutability, serialisability, or thread-safety of the {@code Set}
	 * returned.
	 * 
	 * @see Collectors#toSet()
	 * @param elems
	 * @return
	 */
	@SafeVarargs
	public static <T> Set<T> asSet(T... elems) {
		return Stream.of(elems).collect(Collectors.toSet());
	}

	/**
	 * Returns true if either both elements are null or {@code o1}'s method
	 * {@code equals} returns true when called with {@code o2} as the argument.
	 * 
	 * @param o1
	 * @param o2
	 * @return
	 */
	public static boolean isEqualOrNull(Object o1, Object o2) {
		return (o1 == null && o1 == o2) || (o1 != null && o1.equals(o2));
	}

	/**
	 * Creates a Class-object corresponding to a List of generic type {@code T}.
	 * 
	 * @return
	 */
	@SuppressWarnings({ "unchecked", "rawtypes" })
	public static <T> Class<List<T>> listClass() {
		return (Class) new ArrayList<T>().getClass();
	}

	@SafeVarargs
	public
	static <T> T[] merge(boolean swap, T[] arr, T... moreElements) {
		if (moreElements == null || moreElements.length == 0) {
			return arr;
		}
		T[] prefixElems = swap ? moreElements : arr;
		T[] suffixElems = swap ? arr : moreElements;
	
		T[] result = Arrays.copyOf(prefixElems, arr.length + moreElements.length);
		arraycopy(arr, 0, result, prefixElems.length, suffixElems.length);
		return result;
	}
}
